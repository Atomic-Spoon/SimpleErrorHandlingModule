
Function Invoke-ErrorHandling{
    <#
      .SYNOPSIS
  
        Error\Event reporting and handling. Errors are displayed in a more readable fashion. Optional parameters to also record errors to a log file.
  
      .DESCRIPTION
  
        Error reporting and handling. The function is called when used with PowerShell's "Try,Catch" functionality.
  
        The function grabs the most recent current error object items from the PowerShell error stack.
        
        Using PowerShell's native "Try, Catch, Finally" functionality Invoke-ErrorHandling is called within the "Catch" statement (see examples for more info):
  
          Try {
            Do Something
          } 
          Catch {
            Error Responce
          }
          Finally {
            Follow up action  
          }
  
      .PARAMETER WriteToLogFile
  
        [Optional] Writes the reported error to a designated log file, this also adds verbose info regarding the PS cmdlet that was at fault.
  
        NOTE: If no logfile path is defined (using the -LogFilePath paraameter - see below) the module will write to to a auto-generated file in $env:UserProfile\Documents\
  
      .PARAMETER LogfilePath  
        
        [Optional] The path to a desired log file, used with the -WriteToLogFile option, if the log file path is not defined then the module will write to to a auto-generated file in $env:UserProfile\Documents\ 
  
        
      .PARAMETER FatalError 
      
        [Optional] If the FatalError switch is used, the script will halt/break. If not used the module will allow the script to continue. 
  
      .EXAMPLE
  
        The basic way to catch a PS script error is to just add the  Invoke-ErrorHandling cmdlet into the "Catch" statement when using PowerShell's native "Try,Catch" functionality.
        By default Invoke-ErrorHandling cmdlet the most recent error stack items written to the PS error stack:
  
        Try
        {
          Get-ADUser -justaFakeParam
        }
        Catch
        {
          Invoke-ErrorHandling
        }

        *** ENCOUNTERED RECOVERABLE ERROR ***

        RECOVERABLE ERROR DETAILS:

        ExceptionMessage    : A parameter cannot be found that matches parameter name 'justaFakeParam'.
        FullScriptTextLine  : Get-ADUser -justaFakeParam
        ExceptionType       : ParameterBindingException
        ExceptionID         : NamedParameterNotFound
        ExceptionLineNumber : 3
  
      .EXAMPLE
  
        To add the error details to a logfile, use the -WriteToLogFile parameter: 
  
        Try
        {
          Get-ADUser -justaLoggingFakeParam
        }
        Catch
        {
          Invoke-ErrorHandling -WriteToLogFile
        } 
  
        *** ENCOUNTERED RECOVERABLE ERROR ***

        RECOVERABLE ERROR DETAILS:

        ExceptionMessage    : A parameter cannot be found that matches parameter name 'justaLoggingFakeParam'.
        FullScriptTextLine  : Get-ADUser -justaLoggingFakeParam
        ExceptionType       : ParameterBindingException
        ExceptionID         : NamedParameterNotFound
        ExceptionLineNumber : 3


        INFO: No log file path defined, using autogenerated file path:
        C:\Users\mattg\Documents\SimpleErrorHandling-LogOuput-20210128-212756.txt
  
      .EXAMPLE
  
        To make the script halt\break and stop running if it encountered an eror use the -FatalError parameter:
  
        Try
        {
          Get-ADUser -justaFatalFakeParam
        }
        Catch
        {
          Invoke-ErrorHandling -FatalError
        } 
        
        
        *** ENCOUNTERED FATAL ERROR ***

        FATAL ERROR DETAILS:

        ExceptionMessage    : A parameter cannot be found that matches parameter name 'justaFatalFakeParam'.
        FullScriptTextLine  : Get-ADUser -justaFatalFakeParam
        ExceptionType       : ParameterBindingException
        ExceptionID         : NamedParameterNotFound
        ExceptionLineNumber : 3


        !!! HALTING SCRIPT  !!!

        
      .NOTES
        File Name  : Invoke-ErrorHandling.ps1
        Authors    : Matt Gane
        Requires   : PowerShell version 5.x or greater
        Version    : v1.4 - 28th Jan 2021: Simlified and made a couple of defaults\automatic options
    #>
    Param(
      [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
      [switch]$FatalError,
      [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
      [switch]$WriteToLogFile,
      [Parameter(Mandatory=$false,ValueFromPipeline=$true)]
      $LogFilePath
    )
    $eventTimeStamp = Get-Date
    $isItFatalDoc = If ($FatalError.IsPresent)
    {
      "FATAL ERROR"
    } 
    ELSE 
    {
      "RECOVERABLE ERROR" 
    }
    <# Error items #>
    $errorExceptionMsg = $_.Exception.Message
    $errorExceptionType = $_.Exception.GetType().Name
    $errorExceptionId = $_.Exception.ErrorId
    $errorInvocationLineNumber= $_.InvocationInfo.ScriptLineNumber
    $errorInvocationFullScriptLine = $_.InvocationInfo.Line
    <# Screen output header#>
    Write-Host -ForegroundColor Red "`n*** ENCOUNTERED $isItFatalDoc ***"
    Write-Host "`n$isItFatalDoc DETAILS:`n"
    <# Create a results hashtable to give some easy formatting #>
    $ErrorHashTable = @{ExceptionMessage=$errorExceptionMsg;
                        ExceptionType = $errorExceptionType;
                        ExceptionID=$errorExceptionId;
                        ExceptionLineNumber=$errorInvocationLineNumber;
                        FullScriptTextLine=$($errorInvocationFullScriptLine.trim())}
    [PSCustomObject]$ErrorHashTable
    <# Write Output to log file or not? #>
    If ($writeToLogFile.IsPresent)
    {
      If ([string]::IsNullOrEmpty($LogFilePath))
      {
        $fileDateStamp = $(($eventTimeStamp).tostring("yyyyMMdd-HHmmss"))
        $autoFileName = "SimpleErrorHandling-LogOuput-$fileDateStamp.txt"
        $LogFilePath = "$env:UserProfile\Documents\$autoFileName"
        Write-Host -ForegroundColor Yellow "`nINFO: " -NoNewline
        Write-Host "No log file path defined, using autogenerated file path:`n$LogFilePath`n"
      }
      $errorCommandInfo = $_.InvocationInfo.MyCommand
      <# Write logfile header #>
      Write-Logfile -logFilePath $LogFilePath "`n$(($eventTimeStamp).tostring("dd/MM/yyyy-HH:mm:ss")):`t$isItFatalDoc ENCOUNTERED"
      Write-Logfile -logFilePath $LogFilePath "`n*** Error details: ***`n"
      [PSCustomObject]$ErrorHashTable | Out-String | Write-Logfile -logFilePath $LogFilePath  
      Write-Logfile -logFilePath $LogFilePath "PowerShell Cmdlet Infomation (verbose)`t$errorInvocationName"
      $errorCommandInfo | Select-Object * | Out-String | Write-Logfile -logFilePath $LogFilePath  
      #Write-Logfile -logFilePath $LogFilePath "SourcePSModule:`t$powerShellSource"
      
    }
    <# Exit or continue? #>
    If ($FatalError -eq $true ) 
    {
      Write-Host -ForegroundColor Red "`n!!! HALTING SCRIPT  !!!"
      # Do other this before we halt the script such as email log files etc
      BREAK
    } ELSE {
  
    }  
  } 
  Export-ModuleMember -Function 'Invoke-ErrorHandling'